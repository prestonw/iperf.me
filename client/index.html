<!doctype html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>iperf.me — MVP</title>
<link rel="stylesheet" href="vendor/xterm/xterm.min.css">
<style>
  body { margin:0; background:#0b0e12; color:#e6edf3; font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace }
  header { padding:12px 16px; border-bottom:1px solid #1d2633; display:flex; gap:12px; align-items:center }
  .badge { background:#142033; padding:4px 8px; border-radius:6px; font-size:12px; color:#a5b4c4 }
  #terminal { height: calc(100vh - 54px) }
  .sep { opacity:.5 }
</style>

<header>
  <strong>iperf.me</strong>
  <span class="sep">|</span>
  <span class="badge">edge-friendly, iPerf-style</span>
  <span style="margin-left:auto;font-size:12px;">Inspired by iPerf3 (BSD, ESnet). Not affiliated.</span>
</header>
<div id="terminal"></div>

<script defer src="vendor/xterm/xterm.min.js"></script>
<script defer src="vendor/xterm/xterm-addon-fit.js"></script>

<script>
let WORKER = 'https://edge.iperf.me';
try {
  const u = new URL(location.href);
  const w = u.searchParams.get('worker');
  if (w) WORKER = w;
} catch {}

function start() {
  if (!(window.Terminal && window.FitAddon)) {
    document.getElementById('terminal').textContent = 'Failed to load terminal assets.';
    return;
  }

  const term = new Terminal({ theme:{ background:'#0b0e12' }, scrollback: 2000 });
  const fitAddon = new FitAddon.FitAddon();
  term.loadAddon(fitAddon);
  term.open(document.getElementById('terminal'));
  fitAddon.fit();
  addEventListener('resize', () => fitAddon.fit());

  const writelnWrapped = (s) => {
    const max = Math.max(1, term.cols - 1);
    for (let i = 0; i < s.length; i += max) term.writeln(s.slice(i, i + max));
  };
  const line = writelnWrapped;
  const padL = (s, w) => String(s).padStart(w, ' ');
  const padR = (s, w) => String(s).padEnd(w, ' ');

  // --- Units ---
  const BtoMiB = b => b / (1024 * 1024);         // MiB (2^20)
  const winBytesToMbit = winBytes => (winBytes * 8) / 1e6; // Mbit/s (decimal)

  // --- Config knobs from URL ---
  const q = new URLSearchParams(location.search);
  const durationSec = Math.max(5, Math.min(30, parseInt(q.get('t') || '10', 10)));
  const P = Math.max(1, Math.min(8, parseInt(q.get('p') || '4', 10)));
  let   chunkMiB = Math.max(4, Math.min(64, parseInt(q.get('chunk') || '32', 10))); // start point
  const MAX_CHUNK_MIB = 64;    // matches Worker cap
  const MIN_CHUNK_MIB = 4;

  // --- Adaptive thresholds (per 1s interval downlink) ---
  const UP_SCALE_THRESH   = 700;   // Mbit/s -> double chunk
  const DOWN_SCALE_THRESH = 200;   // Mbit/s -> halve chunk

  // --- State for intervals ---
  let upBytesTotal = 0, downBytesTotal = 0;
  let upWin = 0, downWin = 0;
  let elapsedSec = 0;
  let ticker = null;

  function printHeader() {
    line(`$ iperf3 -c edge-auto -t ${durationSec} -P ${P}`);
    line('[ ID]   Interval         Transfer (MiB)   Bitrate (Mbit/s)   Direction');
    line('[SUM]   0.00-?           (calculating)');
  }

  function printInterval() {
    elapsedSec++;
    // Upload (coarse - we add per POST completion)
    if (upWin > 0) {
      line(`[SUM]  ${padL((elapsedSec-1).toFixed(0),4)}-${padL(elapsedSec.toFixed(0),4)} sec   ${padL(BtoMiB(upWin).toFixed(2),10)}        ${padL(winBytesToMbit(upWin).toFixed(1),10)}       snd`);
      upWin = 0;
    }
    // Download (fine - stream read)
    if (downWin > 0) {
      const mbit = winBytesToMbit(downWin);
      line(`[SUM]  ${padL((elapsedSec-1).toFixed(0),4)}-${padL(elapsedSec.toFixed(0),4)} sec   ${padL(BtoMiB(downWin).toFixed(2),10)}        ${padL(mbit.toFixed(1),10)}       rcv`);
      // Adaptive chunk sizing based on observed per-second rate
      if (mbit > UP_SCALE_THRESH && chunkMiB < MAX_CHUNK_MIB) {
        chunkMiB = Math.min(MAX_CHUNK_MIB, chunkMiB * 2);
      } else if (mbit < DOWN_SCALE_THRESH && chunkMiB > MIN_CHUNK_MIB) {
        chunkMiB = Math.max(MIN_CHUNK_MIB, Math.floor(chunkMiB / 2));
      }
      downWin = 0;
    }
  }

  // --- Upload worker: loop POSTs until end ---
  async function uploadLoop(endTs) {
    while (performance.now() < endTs) {
      const bytes = chunkMiB * 1024 * 1024;
      const payload = new Uint8Array(bytes); // zeros; requests are not compressed
      const res = await fetch(WORKER + '/upload', { method:'POST', body: payload });
      if (!res.ok) break;
      upBytesTotal += bytes;
      upWin += bytes;
      await new Promise(r => setTimeout(r, 0));
    }
  }

  // --- Download worker: stream with flip pattern + nonce ---
  async function downloadLoop(endTs) {
    while (performance.now() < endTs) {
      const remaining = endTs - performance.now();
      if (remaining <= 30) break;

      // Cache-buster: unique nonce each request; pattern=flip to mutate bytes
      const bytes = Math.min(chunkMiB, MAX_CHUNK_MIB) * 1024 * 1024;
      const nonce = Math.random().toString(36).slice(2);
      const url = `${WORKER}/download?bytes=${bytes}&pattern=flip&slabMiB=1&nonce=${nonce}`;

      const resp = await fetch(url);
      if (!resp.ok || !resp.body) break;
      const reader = resp.body.getReader();
      while (true) {
        const { value, done } = await reader.read();
        if (done) break;
        const n = value.byteLength;
        downBytesTotal += n;
        downWin += n;
        if (performance.now() >= endTs) { try { reader.cancel(); } catch {} break; }
      }
      await new Promise(r => setTimeout(r, 0));
    }
  }

  async function runTest() {
    printHeader();

    // Tiny warmup to hide handshake/slow-start blip
    try {
      const r0 = await fetch(`${WORKER}/download?bytes=${1*1024*1024}&pattern=flip&nonce=${Math.random()}`);
      await r0.arrayBuffer();
    } catch {}

    const start = performance.now();
    const end = start + durationSec * 1000;

    ticker = setInterval(printInterval, 1000);
    const ups = Array.from({length: P}, () => uploadLoop(end));
    const dns = Array.from({length: P}, () => downloadLoop(end));
    await Promise.allSettled([...ups, ...dns]);
    clearInterval(ticker);
    printInterval(); // flush residual

    const dur = (performance.now() - start) / 1000;
    const upMiB = BtoMiB(upBytesTotal), downMiB = BtoMiB(downBytesTotal);
    const upMbit = (upBytesTotal * 8 / 1e6) / dur;
    const downMbit = (downBytesTotal * 8 / 1e6) / dur;

    line(`[SUM]  0.00-${dur.toFixed(2)} sec   ${padL(upMiB.toFixed(2),10)}        ${padL(upMbit.toFixed(1),10)}       snd  (P=${P}, chunk≈${chunkMiB} MiB)`);
    line(`[SUM]  0.00-${dur.toFixed(2)} sec   ${padL(downMiB.toFixed(2),10)}        ${padL(downMbit.toFixed(1),10)}       rcv  (P=${P}, chunk≈${chunkMiB} MiB)`);
    line('');

    const bar = (v, max) => {
      const width = Math.max(10, Math.min(50, term.cols - 20));
      const n = Math.max(0, Math.min(width, Math.round((v / max) * width)));
      return '█'.repeat(n) + '·'.repeat(width - n);
    };
    const peak = Math.max(50, upMbit, downMbit);
    line('+-------------------- iperf.me summary --------------------+');
    line('| Duration: ' + padR(dur.toFixed(2) + ' s', 13) + '   Streams: ' + padR(String(P), 2) + '   Chunk*: ' + padR(String(chunkMiB) + ' MiB', 8) + ' |');
    line('| Up:   '  + padL(upMiB.toFixed(2), 9) + ' MiB  ' + padL(upMbit.toFixed(1), 8) + ' Mbit/s  ' + bar(upMbit,  peak) + ' |');
    line('| Down: ' + padL(downMiB.toFixed(2), 9) + ' MiB  ' + padL(downMbit.toFixed(1), 8) + ' Mbit/s  ' + bar(downMbit, peak) + ' |');
    line('+-----------------------------------------------------------+');
    line('');
    line('* Adaptive per second; tune start with ?t=10&p=4&chunk=32 . Units: MiB (2^20), Mbit/s (10^6).');
  }

  (async () => {
    try { await runTest(); } catch (e) { line('Error: ' + (e?.message || e)); }
  })();
}

addEventListener('DOMContentLoaded', start);
</script>
