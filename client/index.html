<!doctype html>
<html>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>iperf.me — MVP</title>

<link rel="stylesheet" href="vendor/xterm/xterm.min.css" />
<style>
  :root{--bg:#0b0e12;--fg:#e6edf3;--mut:#a5b4c4;--line:#1d2633;--pill:#142033}
  html,body{height:100%}
  body{
    margin:0;background:var(--bg);color:var(--fg);
    font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
    font-size:12px;line-height:1.15;
    -webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale
  }
  header{padding:8px 12px;border-bottom:1px solid var(--line);display:flex;align-items:center;gap:8px}
  .badge{background:var(--pill);color:var(--mut);padding:3px 6px;border-radius:6px;font-size:11px;white-space:nowrap}
  .sep{opacity:.5}
  #terminal{height:calc(100vh - 46px)}
</style>

<body>
<header>
  <strong>iperf.me</strong><span class="sep">|</span>
  <span class="badge">edge-friendly</span>
  <span class="badge">iPerf-style</span>
  <span style="margin-left:auto;font-size:11px;color:#8fa5b7">Inspired by iPerf3 (BSD, ESnet). Not affiliated.</span>
</header>
<div id="terminal"></div>

<script defer src="vendor/xterm/xterm.min.js"></script>
<script defer src="vendor/xterm/xterm-addon-fit.js"></script>

<script>
(async function(){
  const q = new URLSearchParams(location.search);
  const T       = Math.max(1, Math.min(parseInt(q.get('t')||'10',10), 60));
  const Pwant   = Math.max(1, Math.min(parseInt(q.get('p')||'4',10), 16));
  const slabMiB = Math.max(1, Math.min(parseInt(q.get('chunk')||'32',10), 64));
  const batch   = Math.max(8, Math.min(parseInt(q.get('batch')||'128',10), 1024));
  const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

  // Default to workers.dev; override with ?worker=
  const DEFAULT_WORKER = 'https://iperf-me-mvp.iperf.workers.dev';
  let WORKER = DEFAULT_WORKER;
  try { const u = new URL(location.href); WORKER = u.searchParams.get('worker') || WORKER; } catch {}

  await new Promise(r => addEventListener('DOMContentLoaded', r, { once:true }));
  if (!(window.Terminal && window.FitAddon)) { document.getElementById('terminal').textContent = 'terminal load error'; return; }

  const term = new Terminal({ theme:{ background:'#0b0e12' }, fontSize:12, lineHeight:1.15, scrollback:2000, convertEol:true });
  const fit  = new FitAddon.FitAddon();
  term.loadAddon(fit); term.open(document.getElementById('terminal')); fit.fit();
  addEventListener('resize', () => fit.fit());

  const line = s => { const max=Math.max(1,term.cols-1); for(let i=0;i<s.length;i+=max) term.writeln(s.slice(i,i+max)); };
  const pad  = (v,w)=> String(v).padStart(w,' ');
  const toMiB= b => b/(1024*1024);
  const toMb = (b,s)=> (b*8/1e6)/Math.max(s,1e-6);
  const nonce= ()=> Math.random().toString(36).slice(2);

  async function printAnchored(getTotalBytes, dir, seconds, t0){
    let lastBytes = 0, lastBoundary = t0;
    for (let s=0; s<seconds; s++){
      const boundary = t0 + (s+1)*1000;
      const sleep = Math.max(0, boundary - performance.now());
      if (sleep>0) await new Promise(r=>setTimeout(r, sleep));
      const now = performance.now();
      const total = getTotalBytes();
      const deltaB = total - lastBytes;
      const deltaS = (now - lastBoundary)/1000;
      line(`[SUM]   ${pad(s,2)}- ${pad(s+1,2)} sec   ${pad(toMiB(deltaB).toFixed(2),7)}        ${pad(toMb(deltaB,deltaS).toFixed(1),7)}       ${dir}`);
      lastBytes = total; lastBoundary = now;
    }
  }

  // --------------------- Upload phase (capped 100 MiB total) ---------------------
  line(`$ iperf3 -c edge-auto -t ${T} -P 1`);
  line('[ ID]   Interval         Transfer (MiB)   Bitrate (Mbit/s)   Direction');

  const UP_TOTAL_CAP = 100 * 1024 * 1024; // 100 MiB
  const upChunkSize  = 1024*1024*(isMobile ? 2 : 4); // 2 MiB mobile, 4 MiB desktop
  const baseBuf      = new Uint8Array(upChunkSize);
  let upBytes = 0;

  const upStart = performance.now();
  const upUntil = upStart + T*1000;
  const upTicker = printAnchored(()=>upBytes, 'snd', T, upStart);

  (async () => {
    while (performance.now() < upUntil && upBytes < UP_TOTAL_CAP) {
      // slice last chunk if needed to not exceed 100 MiB
      const room = UP_TOTAL_CAP - upBytes;
      const sendSize = Math.min(room, upChunkSize);
      const body = new Blob([sendSize === upChunkSize ? baseBuf : baseBuf.subarray(0, sendSize)],
                            { type:'application/octet-stream' });

      try {
        const res = await fetch(`${WORKER}/upload?nonce=${nonce()}`, {
          method:'POST', body, cache:'no-store',
          headers:{ 'Content-Type':'application/octet-stream' }
        });
        if (res.ok) upBytes += body.size;
      } catch {
        // swallow transient errors
      }

      // if we hit the cap exactly, stop now
      if (upBytes >= UP_TOTAL_CAP) break;
    }
  })();

  await upTicker;
  const upCappedNote = upBytes >= UP_TOTAL_CAP ? ' (capped at 100 MiB)' : '';
  line(`[SUM]  0.00-${T.toFixed(2)} sec   ${pad(toMiB(upBytes).toFixed(2),7)}        ${pad(toMb(upBytes, Math.min(T, (performance.now()-upStart)/1000)).toFixed(1),7)}       snd  (P=1)${upCappedNote}`);
  line('');

  // --------------------- Reverse phase (download) ---------------------
  line(`$ iperf3 -c edge-auto -R -t ${T} -P ${Pwant}`);
  line('[ ID]   Interval         Transfer (MiB)   Bitrate (Mbit/s)   Direction');

  let dnBytes = 0;
  const dnStart = performance.now();
  const dnUntil = dnStart + T*1000;
  const dnTicker = printAnchored(()=>dnBytes, 'rcv', T, dnStart);

  async function oneStream(signal) {
    const url = `${WORKER}/d?t=${T}&slabMiB=${slabMiB}&batch=${batch}&nonce=${nonce()}`;
    const r = await fetch(url, { cache:'no-store', headers:{ 'Accept-Encoding':'identity' }, signal });
    if (!r.ok || !r.body) throw new Error(`bad response ${r.status}`);
    const reader = r.body.getReader();
    while (true) {
      const { value, done } = await reader.read();
      if (done) break;
      dnBytes += value.byteLength;
      if (performance.now() >= dnUntil) break;
    }
  }

  async function runStreams(Pinit) {
    let P = Pinit;
    const controllers = new Set();
    const tasks = new Set();

    function startOne() {
      const ac = new AbortController();
      controllers.add(ac);
      const startedAt = performance.now();
      const p = oneStream(ac.signal).catch((e) => {
        // Early failure → replace once and back off concurrency
        if (performance.now() - startedAt < 1000) {
          line(`[DBG] stream early fail: ${e?.message || e}`);
          if (P > 1) P = Math.max(1, Math.floor(P/2));
          const ac2 = new AbortController();
          controllers.add(ac2);
          const p2 = oneStream(ac2.signal).catch(()=>{}).finally(()=>{ tasks.delete(p2); controllers.delete(ac2); });
          tasks.add(p2);
        }
      }).finally(() => { tasks.delete(p); controllers.delete(ac); });
      tasks.add(p);
    }

    for (let i=0;i<P;i++) startOne();

    // modest desktop boost after 2s if slow
    if (!isMobile && P < 16) {
      await new Promise(r => setTimeout(r, Math.max(0, (dnStart + 2000) - performance.now())));
      const mbps2s = toMb(dnBytes, Math.max(2, (performance.now() - dnStart)/1000));
      if (mbps2s < 800) {
        const extra = Math.min(16 - P, 4);
        for (let i=0;i<extra;i++) startOne();
      }
    }

    await new Promise(r => setTimeout(r, Math.max(0, dnUntil - performance.now())));
    controllers.forEach(c => c.abort('deadline'));
    await Promise.allSettled([...tasks]);
  }

  await runStreams(Pwant);
  await dnTicker;
  line(`[SUM]  0.00-${T.toFixed(2)} sec   ${pad(toMiB(dnBytes).toFixed(2),7)}        ${pad(toMb(dnBytes,T).toFixed(1),7)}       rcv  (P=${Math.min(Pwant,16)})`);
})();
</script>
</body>
</html>
